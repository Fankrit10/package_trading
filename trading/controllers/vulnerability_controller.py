"""
Module for managing the vulnerability remediation process.

This module defines the `VulnerabilityController` class, which orchestrates the workflow for
analyzing vulnerability reports, running automated security remediations, tracking progress,
and retrieving results. It integrates with the `SecurityRemediationCrew` to process reports
and validate remediated code.
"""
# pylint: disable=W0718

from typing import Dict, Any, Optional
import os
import json
from datetime import datetime

from trading.crews.security_crew import SecurityRemediationCrew


class VulnerabilityController:
    """
    Controls and monitors the vulnerability remediation workflow.

    The `VulnerabilityController` class manages the full lifecycle of a remediation process:
    starting a new remediation, executing it, tracking its state, and retrieving relevant data
    such as vulnerability reports, original and remediated code, and validation results.
    """

    def __init__(self):
        """
        Initializes the vulnerability controller and sets the initial state.

        The controller starts in an idle state and initializes a new instance of
        `SecurityRemediationCrew`, which performs the actual remediation logic.
        """
        self.crew = SecurityRemediationCrew()
        self.state = {
            "status": "idle",
            "message": "No remediation in progress",
            "started_at": None,
            "completed_at": None,
            "result": None
        }

    def start_remediation(self, report_path: str, output_path: str) -> Dict[str, Any]:
        """
        Initializes the remediation process for a given vulnerability report.

        This method validates input paths and ensures no other remediation is currently running.
        It sets the controller state to 'starting' and returns basic information about
        the queued remediation.

        Args:
            report_path (str): The path to the vulnerability report file.
            output_path (str): The path where the remediation results should be saved.

        Returns:
            Dict[str, Any]: A dictionary with the remediation start status, message,
            and file path details.
        """
        if self.state["status"] == "running":
            return {
                "success": False,
                "error": "Remediation already in progress",
                "status": self.state["status"],
                "started_at": self.state["started_at"]
            }

        if not os.path.exists(report_path):
            return {
                "success": False,
                "error": f"Vulnerability report not found at {report_path}"
            }

        self.state = {
            "status": "starting",
            "message": "Remediation queued",
            "started_at": None,
            "completed_at": None,
            "result": None
        }

        return {
            "success": True,
            "message": "Remediation started",
            "status": "starting",
            "report_path": report_path,
            "output_path": output_path
        }

    def run_remediation(self, report_path: str, output_path: str):
        """
        Executes the vulnerability remediation process.

        This method updates the internal state to 'running', processes the vulnerability report
        through the `SecurityRemediationCrew`, and stores the result. If any error occurs,
        the state is updated to 'failed'.

        Args:
            report_path (str): Path to the vulnerability report file.
            output_path (str): Path where the remediation results will be written.
        """
        try:
            self.state["status"] = "running"
            self.state["message"] = "Processing vulnerabilities..."
            self.state["started_at"] = datetime.now().isoformat()

            result = self.crew.process_vulnerability_report(report_path, output_path)

            self.state["status"] = "completed"
            self.state["message"] = "Remediation completed successfully"
            self.state["completed_at"] = datetime.now().isoformat()
            self.state["result"] = result

        except Exception as e:
            self.state["status"] = "failed"
            self.state["message"] = f"Error: {str(e)}"
            self.state["completed_at"] = datetime.now().isoformat()

    def get_status(self) -> Dict[str, Any]:
        """
        Retrieves the current remediation process status.

        Returns:
            Dict[str, Any]: A dictionary containing the current status, message,
            start time, completion time, and whether a result is available.
        """
        return {
            "status": self.state["status"],
            "message": self.state["message"],
            "started_at": self.state["started_at"],
            "completed_at": self.state["completed_at"],
            "has_result": self.state["result"] is not None
        }

    def get_result(self) -> Optional[Dict[str, Any]]:
        """
        Retrieves the full result of the last remediation process.

        Returns:
            Optional[Dict[str, Any]]: The remediation result data, or None if unavailable.
        """
        return self.state["result"]

    def get_remediation_plan(self, plan_path: str) -> Optional[Dict[str, Any]]:
        """
        Loads and returns a remediation plan from a given file path.

        Args:
            plan_path (str): Path to the remediation plan JSON file.

        Returns:
            Optional[Dict[str, Any]]: Parsed remediation plan data,
            or None if the file is missing.
        """
        if not os.path.exists(plan_path):
            return None

        with open(plan_path, 'r', encoding='utf-8') as f:
            return json.load(f)

    def get_vulnerabilities(self, report_path: str) -> Optional[Dict[str, Any]]:
        """
        Loads and returns vulnerabilities from a given report path.

        Args:
            report_path (str): Path to the vulnerability report JSON file.

        Returns:
            Optional[Dict[str, Any]]: Parsed vulnerability data,
            or None if the file is missing.
        """
        if not os.path.exists(report_path):
            return None

        with open(report_path, 'r', encoding='utf-8') as f:
            return json.load(f)

    def get_original_code(self, report_path: str,
                          vulnerability_id: str) -> Optional[Dict[str, Any]]:
        """
        Retrieves the original (unremediated) source code for a specific vulnerability.

        Args:
            report_path (str): Path to the vulnerability report JSON file.
            vulnerability_id (str): The unique identifier of the vulnerability.

        Returns:
            Optional[Dict[str, Any]]: Dictionary containing file path, original code,
            and vulnerability details, or None if not found.
        """
        if not os.path.exists(report_path):
            return None

        with open(report_path, 'r', encoding='utf-8') as f:
            report_data = json.load(f)

        vulnerability = next(
            (v for v in report_data["vulnerabilities"] if v["id"] == vulnerability_id),
            None
        )

        if not vulnerability:
            return None

        file_path = vulnerability["file_path"]

        if not os.path.exists(file_path):
            return None

        with open(file_path, 'r', encoding='utf-8') as f:
            code_content = f.read()

        return {
            "vulnerability_id": vulnerability_id,
            "file_path": file_path,
            "code": code_content,
            "vulnerability": vulnerability
        }

    def get_remediated_code(self, plan_path: str,
                            vulnerability_id: str) -> Optional[Dict[str, Any]]:
        """
        Retrieves the remediated source code for a specific vulnerability.

        Args:
            plan_path (str): Path to the remediation plan JSON file.
            vulnerability_id (str): The unique identifier of the vulnerability.

        Returns:
            Optional[Dict[str, Any]]: Dictionary containing the remediated code, file path,
            validation status, and remediation action, or None if not found.
        """
        if not os.path.exists(plan_path):
            return None

        with open(plan_path, 'r', encoding='utf-8') as f:
            plan_data = json.load(f)

        vulnerability = next(
            (v for v in plan_data["vulnerabilidades_remediadas"] if v["id"] == vulnerability_id),
            None
        )

        if not vulnerability:
            return None

        remediated_file = vulnerability["file_path"]

        if not os.path.exists(remediated_file):
            return None

        with open(remediated_file, 'r', encoding='utf-8') as f:
            code_content = f.read()

        return {
            "vulnerability_id": vulnerability_id,
            "file_path": remediated_file,
            "code": code_content,
            "status": vulnerability["resultado_validacion"],
            "action": vulnerability["accion"]
        }

    def reset_state(self):
        """
        Resets the controller state to the initial idle configuration.

        This clears any previous remediation status, messages, timestamps, and results.
        """
        self.state = {
            "status": "idle",
            "message": "No remediation in progress",
            "started_at": None,
            "completed_at": None,
            "result": None
        }
