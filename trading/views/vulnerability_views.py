"""
API router for managing security vulnerability remediation workflows.

This module defines the REST endpoints for initiating, monitoring, and retrieving
security remediation processes. It integrates with the `VulnerabilityController`
to handle vulnerability reports, remediation plans, and associated code files.
"""

import os
from fastapi import APIRouter, HTTPException, BackgroundTasks
from fastapi.responses import JSONResponse, FileResponse
from pydantic import BaseModel
from trading.controllers.vulnerability_controller import VulnerabilityController


router = APIRouter(prefix="/api/security", tags=["Security Remediation"])

controller = VulnerabilityController()


class RemediationRequest(BaseModel):
    """
    Schema for remediation request payload.

    Attributes:
        report_path (str): Path to the input vulnerability report JSON file.
        output_path (str): Path where the generated remediation plan will be saved.
    """
    report_path: str = "data/input/reporte_vulnerabilidades.json"
    output_path: str = "outputs/plan_remediacion.json"


@router.post("/remediate")
async def start_remediation(
    request: RemediationRequest,
    background_tasks: BackgroundTasks
) -> JSONResponse:
    """
    Starts the vulnerability remediation process asynchronously.

    This endpoint validates the provided report path, initiates the remediation
    process using the controller, and queues it as a background task.
    Returns an immediate response indicating that processing has started.

    Args:
        request (RemediationRequest): The input containing paths for the report and output plan.
        background_tasks (BackgroundTasks): FastAPI background task handler.

    Returns:
        JSONResponse: A response with process status and relevant file path details.
    """
    result = controller.start_remediation(request.report_path, request.output_path)

    if not result["success"]:
        status_code = 409 if "already in progress" in result.get("error", "") else 404
        return JSONResponse(
            status_code=status_code,
            content=result
        )

    background_tasks.add_task(
        controller.run_remediation,
        request.report_path,
        request.output_path
    )

    return JSONResponse(
        status_code=202,
        content=result
    )


@router.get("/status")
async def get_remediation_status() -> JSONResponse:
    """
    Retrieves the current status of the remediation process.

    Returns:
        JSONResponse: The current process status, including message, timestamps,
        and whether a result is available.
    """
    status = controller.get_status()
    return JSONResponse(content=status)


@router.get("/result")
async def get_remediation_result() -> JSONResponse:
    """
    Retrieves the final result of the most recent remediation process.

    Raises:
        HTTPException: If no remediation result is available.

    Returns:
        JSONResponse: The structured remediation result data.
    """
    result = controller.get_result()

    if result is None:
        raise HTTPException(
            status_code=404,
            detail="No remediation result available"
        )

    return JSONResponse(content=result)


@router.get("/plan/download")
async def download_remediation_plan() -> FileResponse:
    """
    Downloads the generated remediation plan as a JSON file.

    Raises:
        HTTPException: If the remediation plan file does not exist.

    Returns:
        FileResponse: The remediation plan file for download.
    """
    plan_path = "outputs/plan_remediacion.json"

    if not os.path.exists(plan_path):
        raise HTTPException(
            status_code=404,
            detail="Remediation plan not found"
        )

    return FileResponse(
        path=plan_path,
        media_type="application/json",
        filename="plan_remediacion.json"
    )


@router.get("/plan")
async def get_remediation_plan() -> JSONResponse:
    """
    Retrieves the current remediation plan as JSON content.

    Raises:
        HTTPException: If the remediation plan is not found.

    Returns:
        JSONResponse: The parsed remediation plan data.
    """
    plan_path = "outputs/plan_remediacion.json"
    plan = controller.get_remediation_plan(plan_path)

    if plan is None:
        raise HTTPException(
            status_code=404,
            detail="Remediation plan not found"
        )

    return JSONResponse(content=plan)


@router.get("/vulnerabilities")
async def get_vulnerabilities() -> JSONResponse:
    """
    Returns the list of vulnerabilities from the uploaded report.

    Raises:
        HTTPException: If the vulnerability report is missing or invalid.

    Returns:
        JSONResponse: Parsed vulnerability data from the report.
    """
    report_path = "data/input/reporte_vulnerabilidades.json"
    vulnerabilities = controller.get_vulnerabilities(report_path)

    if vulnerabilities is None:
        raise HTTPException(
            status_code=404,
            detail="Vulnerability report not found"
        )

    return JSONResponse(content=vulnerabilities)


@router.get("/code/original/{vulnerability_id}")
async def get_original_code(vulnerability_id: str) -> JSONResponse:
    """
    Retrieves the original (unremediated) code for a specific vulnerability.

    Args:
        vulnerability_id (str): The unique identifier of the vulnerability.

    Raises:
        HTTPException: If the corresponding code file cannot be found.

    Returns:
        JSONResponse: The original source code and vulnerability details.
    """
    report_path = "data/input/reporte_vulnerabilidades.json"
    code_data = controller.get_original_code(report_path, vulnerability_id)

    if code_data is None:
        raise HTTPException(
            status_code=404,
            detail=f"Original code for {vulnerability_id} not found"
        )

    return JSONResponse(content=code_data)


@router.get("/code/remediated/{vulnerability_id}")
async def get_remediated_code(vulnerability_id: str) -> JSONResponse:
    """
    Retrieves the remediated (fixed) code for a specific vulnerability.

    Args:
        vulnerability_id (str): The unique identifier of the vulnerability.

    Raises:
        HTTPException: If the remediated code file cannot be found.

    Returns:
        JSONResponse: The remediated source code, status, and remediation details.
    """
    plan_path = "outputs/plan_remediacion.json"
    code_data = controller.get_remediated_code(plan_path, vulnerability_id)

    if code_data is None:
        raise HTTPException(
            status_code=404,
            detail=f"Remediated code for {vulnerability_id} not found"
        )

    return JSONResponse(content=code_data)


@router.delete("/reset")
async def reset_remediation_state() -> JSONResponse:
    """
    Resets the remediation controller state to its initial configuration.

    Returns:
        JSONResponse: A confirmation message indicating successful reset.
    """
    controller.reset_state()

    return JSONResponse(content={
        "message": "Remediation state reset successfully"
    })
